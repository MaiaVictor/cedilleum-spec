\documentclass{article}

\usepackage{amsmath,amssymb,amsthm}
%\usepackage{unicode-math}
\usepackage{url}
\usepackage{fullpage}

\usepackage{subcaption}
\usepackage{cedilleverbatim}
\DeclareUnicodeCharacter{03BC}{\ensuremath{\mu}}
\DeclareUnicodeCharacter{21A6}{\ensuremath{\mapsto}}
\DeclareUnicodeCharacter{25CF}{\ensuremath{\medbullet}}
\DeclareUnicodeCharacter{1D48C}{\ensuremath{\kappa}}

\begin{document}

\title{The Cedilleum Language Specification \\ \large Syntax, Typing, Reduction,
  and Elaboration }

\author{Christopher Jenkins}

\maketitle

\section{Syntax}

\begin{figure}[h]
  \[
    \begin{array}{llll}
      id & &
      & \textnormal{identifiers for definitions}
      \\ u & &
      & \textnormal{term variables}
      \\ X & &
      & \textnormal{type variables}
      \\ k & &
      & \textnormal{kind variables}
      \\ x & ::= & id\ |\ u\ |\ X\
      & \textnormal{non-kind variables}
    \end{array}
  \]
  \caption{Identifiers}
  \label{fig:identifiers}
\end{figure}

\paragraph{Identifiers}
Figure \ref{fig:identifiers} gives the metavariables used in our grammar for
identifiers. We consider all identifiers as coming from two distinct lexical
``pools'' -- regular identifiers (consisting of identifiers $id$ given for
modules and definitions, term variables $u$, and type variables $X$) and kind
identifiers $k$. In Cedilleum source files (as in the parent language Cedille)
kind variables should be prefixed with $\kappa$.

\begin{figure}[h]
  \[
    \begin{array}{llll}
      uterms
      & ::= & u
      & \text{variables}
      \\ & & \textbf{Œª}\ u \textbf{.}\ uterm
      & \text{functions}
      \\ & & uterm\ uterm
      & \text{applications}
    \end{array}
  \]
  \caption{Untyped terms}
  \label{fig:pure-terms}
\end{figure}

\paragraph{Untyped Terms}
The grammar of pure (untyped) terms is that of the Œª-calculus.

\begin{figure}[h]
  \[
    \begin{array}{llll}
      % module stuff
      \\ mod
      & ::= & \textbf{module}\ id\ \textbf{.}\ imprt^*\ cmd^*\
      & \textnormal{module declarations}
      \\ imprt
      & ::= & \textbf{import}\ id\ \textbf{.}
      & \textnormal{module imports}
      \\ cmd
      & ::= & defTermOrType
      & \textnormal{definitions}
      \\ & & defDataType
      \\ & & defKind
      % definitions
      \\ 
      \\ defTermOrType
      & ::= & id\ checkType^?\ \textbf{=}\ term\ \textbf{.}
      & \textnormal{term definition}
      \\ & & id\ \textbf{:}\ kind\ \textbf{=}\ type\ \textbf{.}
      & \textnormal{type definition}
      \\ defKind
      & ::= & k\ \textbf{=}\ kind
      & \text{kind definition}
      \\ defDataType
      & ::= & \textbf{data}\ id\ param^*\ \textbf{:}\ kind\ \textbf{=}\
              constr^*\ \textbf{.}
      & \textnormal{datatype definitions}
     % auxilliary categories for definitions
      \\ 
      \\ checkType
      & ::= & \textbf{:}\ type
      & \textnormal{annotation for term definition}
      \\ param
      & ::= & \textbf{(}x\ \textbf{:}\ typeOrKind \textbf{)}
      \\ typeOrKind
      & ::= & type
      \\ & & kind
      \\ constr
      & ::= & \textbf{\textbar}\ id\ \textbf{:}\ type
    \end{array}
  \]
  \caption{Modules and definitions}
  \label{fig:mods-defs}
\end{figure}

\paragraph{Modules and Definitions}
All Cedilleum source files start with $mod$, which consists of a module
declaration, a sequence of import statements which bring into scope definitions
from other source files, and a sequence of \textit{commands} defining terms,
types, and kinds. As an illustration, consider the first few lines of a
hypothetical \texttt{list.ced}:

\begin{verbatim}
module vec .

import nat .
\end{verbatim}

\noindent Imports are handled first by consulting a global options files
known to the Cedilleum compiler (on *nix systems \verb|~/.cedille/options|)
containing a search path of directories, and next (if that fails) by searching
the directory containing the file being checked.

Term and type definitions are given with an identifier, a classifier (type or
kind, resp.) to check the definition against, and the definition. For term
definitions, giving the type is optional. As an example, consider the
definitions for the type of Church-encoded lists and two variants of the nil
constructor, the first with a type annotation and the second without:

\begin{verbatim}
cList : ‚òÖ ‚ûî ‚òÖ
      = Œª A : ‚òÖ . ‚àÄ X : ‚òÖ . (A ‚ûî X ‚ûî X) ‚ûî X ‚ûî X .

cNil  : ‚àÄ A : ‚òÖ . cList ¬∑ A
      = Œõ A . Œõ X . Œª c . Œª n . n .
cNil' = Œõ A : ‚òÖ . Œõ X : ‚òÖ . Œª c : A ‚ûî X ‚ûî X . Œª n : X . n .
\end{verbatim}

Kind definitions are given without classifiers (all kinds have super-kind
$\Box$), e.g. \verb;ùíåfunc = ‚òÖ ‚ûî ‚òÖ;

Inductive datatype definitions take a set of \textit{parameters} (term and type
variables which remain constant throughout the definition) well as a set of
\textit{indices} (term and type variables which \textit{can} vary), followed by
zero or more constructors. Each constructor begins with
\textbf{\textbar}\footnote{The first of these is optional.} and then an
identifier and type is given. As an example, consider the following two
definitions for lists and vectors (length-indexed lists).

\begin{verbatim}
data List (A : ‚òÖ) : ‚òÖ =
  | nil  : List
  | cons : A ‚ûî List ‚ûî List
  .
data Vec (A : ‚òÖ) : Nat ‚ûî ‚òÖ =
  | vnil  : Vec Z
  | vcons : ‚àÄ n : Nat . A ‚ûî Vec n ‚ûî Vec (S n)
  .
\end{verbatim}

\begin{figure}[h]
  \[
    \begin{array}{llll}
      \\ kind
      & ::= & \textbf{Œ†}\ x\ \textbf{:}\ typeOrKind\ \textbf{.}\ kind
      & \textnormal{explicit product}
      \\ & & typeOrKind\ \textbf{‚ûî}\ kind
      & \textnormal{kind arrow}
      \\ & & \textbf{‚òÖ}
      & \text{the kind of types that classify terms}
      \\ & & \textbf{(}kind\textbf{)}
      \\ 
      \\ type
      & ::= & \textbf{Œ†}\ x\ \textbf{:}\ type\ \textbf{.}\ type
         & \textnormal{explicit product}
      \\ & &  \textbf{‚àÄ}\ x\ \textbf{:}\ typeOrKind\ \textbf{.}\ type
         & \textnormal{implicit product}
      \\ & &  \textbf{Œª}\ x\ \textbf{:}\ typeOrKind\ \textbf{.}\ type
         & \textnormal{type-level function}
      \\ & & type\ \textbf{‚ûæ}\ type
         & \textnormal{arrow with erased domain}
      \\ & & type\ \textbf{‚ûî}\ type
         & \textnormal{normal arrow type}
      \\ & & type\ \textbf{¬∑}\ type
         & \text{application to another type}
      \\ & & type\ term
         & \text{application to a term}
      \\ & & \textbf{\{}\ uterm\ ‚âÉ\ uterm \textbf{\}}
         & \textnormal{untyped equality}
      \\ & & \textbf{(}type\textbf{)}
      \\ & & X
         & \text{type variable}
      \\ & & \bullet
         & \text{hole for incomplete types}
    \end{array}
  \]
  \caption{Kinds and types}
  \label{fig:kinds-types}
\end{figure}

\begin{figure}[h]
  \[
    \begin{array}{llll}
      \\ term
      & ::= & \textbf{Œª}\ x\ class^?\ \textbf{.}\ term
      & \textnormal{normal abstraction}
      \\ & & \textbf{Œõ}\ x\ class^?\ \textbf{.}\ term
      & \textnormal{erased abstraction}
      \\ & & \textbf{[}\ defTermOrType\ \textbf{]}\ \textbf{-}\ term
      & \textnormal{let}
      \\ & & \textbf{œÅ}\ term\ \textbf{-}\ term
      & \text{equality elimination by rewriting}
      \\ & & \textbf{œÜ}\ term\ \textbf{-}\ term\ \textbf{\{} term \textbf{\}}
      & \text{type cast}
      \\ & & \textbf{œá}\ type^?\ \textbf{-}\ term
      & \text{check a term against a type}
      \\ & & \textbf{Œ¥}\ \textbf{-}\ term
      & \text{ex falso quodlibet}
      \\ & & \textbf{Œ∏}\ term\ term^*
      & \text{elimination with a motive}
      \\ & & term\ term
      & \text{applications}
      \\ & & term\ \textbf{-}\ term
      & \text{application to an erased term}
      \\ & & term\ \textbf{¬∑}\ type
      & \text{application to a type}
      % \\ & & term\ arg^*
      % & \textnormal{applications}
      \\ & & \textbf{Œ≤}\ \textbf{\{} term \textbf{\}}
      & \textnormal{reflexivity of equality}
      \\ & & \textbf{œÇ}\ term
      & \textnormal{symmetry of equality}
      \\ & & \textbf{Œº}\ term\ motive^?\ \textbf{\{}\ case^*\ \textbf{\}}
      & \textnormal{pattern match and fixpoint}
      \\ & & u
      & \text{term variable}
      \\ & & \textbf{(}term\textbf{)}
      \\ & & \bullet
      & \text{hole for incomplete term}
      \\ vararg
      & ::= & u
      & \text{normal constructor argument}
      \\ & & \textbf{-}\ u
      & \text{erased constructor argument}
      \\ & & \textbf{¬∑}\ X
      & \text{type constructor argument}
      \\ class
      & ::= & \textbf{:}\ typeOrKind
      \\ motive
      & ::= & \textbf{@}\ type
      & \textnormal{motive for induction}
      \\ case
      & ::= & \textbf{\textbar}\ id\ arg^*\ \textbf{‚Ü¶}\ term
      & \text{pattern-matching cases}
    \end{array}
  \]
  \caption{Annotated Terms}
  \label{fig:ann-terms}
\end{figure}

\paragraph{Expression Language}

In Cedilleum, the expression language is stratified into three main ``classes'':
kinds, types, and terms. Kinds and types are listed in Figure
\ref{fig:kinds-types} and terms are listed in Figure \ref{fig:ann-terms} along
with some auxiliary grammatical categories. In both of these figures, the
constructs forming expressions are listed from lowest to highest precedence --
``abstractors'' ($\lambda\ \Lambda\ \Pi\ \forall$) bind most loosely and
parentheses most tightly. Associativity is as-expected, with arrows (‚ûî ‚ûæ) and
applications being left-associative and abstractors are right-associative.

\end{document}