\documentclass{article}

\usepackage{amsmath,amssymb,amsthm}
%\usepackage{unicode-math}
\usepackage{url}
\usepackage{fullpage}

\usepackage{subcaption}
\usepackage{cedilleverbatim}
\DeclareUnicodeCharacter{03BC}{\ensuremath{\mu}}
\DeclareUnicodeCharacter{21A6}{\ensuremath{\mapsto}}
\DeclareUnicodeCharacter{25CF}{\ensuremath{\medbullet}}

\begin{document}

\title{The Cedilleum Language Specification \\ \large Syntax, Typing, Reduction,
  and Elaboration }

\author{Christopher Jenkins}

\maketitle

\section{Syntax}

\begin{figure}[h]
  \[
    \begin{array}{llll}
      id & &
      & \textnormal{identifiers for definitions}
      \\ u & &
      & \textnormal{term variables}
      \\ X & &
      & \textnormal{type variables}
      \\ k & &
      & \textnormal{kind variables}
      \\ x & ::= & id\ |\ u\ |\ X\
      & \textnormal{non-kind variables}
    \end{array}
  \]
  \caption{Identifiers}
  \label{fig:identifiers}
\end{figure}

\paragraph{Identifiers}
Figure \ref{fig:identifiers} gives the metavariables used in our grammar for
identifiers. We consider all identifiers as coming from two distinct lexical
``pools'' -- regular identifiers (consisting of identifiers $id$ given for
modules and definitions, term variables $u$, and type variables $X$) and kind
identifiers $k$. In Cedilleum source files (as in the parent language Cedille)
kind variables should be prefixed with $\kappa$.

\begin{figure}[h]
  \[
    \begin{array}{llll}
      uterms
      & ::= & u
      & \text{variables}
      \\ & & \textbf{λ}\ u \textbf{.}\ uterm
      & \text{functions}
      \\ & & uterm\ uterm
      & \text{applications}
    \end{array}
  \]
  \caption{Untyped terms}
  \label{fig:pure-terms}
\end{figure}

\paragraph{Untyped Terms}
The grammar of pure (untyped) terms is that of the λ-calculus.

\begin{figure}[h]
  \[
    \begin{array}{llll}
      % module stuff
      \\ mod
      & ::= & \textbf{module}\ id\ \textbf{.}\ imprt^*\ cmd^*\
      & \textnormal{module declarations}
      \\ imprt
      & ::= & \textbf{import}\ id\ \textbf{.}
      & \textnormal{module imports}
      \\ cmd
      & ::= & defTermOrType
      & \textnormal{definitions}
      \\ & & defDataType
      \\ & & defKind
      % definitions
      \\ 
      \\ defTermOrType
      & ::= & id\ checkType^?\ \textbf{=}\ term\ \textbf{.}
      & \textnormal{term definition}
      \\ & & id\ \textbf{:}\ kind\ \textbf{=}\ type\ \textbf{.}
      & \textnormal{type definition}
      \\ defDataType
      & ::= & \textbf{data}\ id\ param^*\ \textbf{:}\ kind\ \textbf{=}\
              constr^*\ \textbf{.}
      & \textnormal{datatype definitions}
      \\ defKind
      & ::= & k\ \textbf{=}\ kind
      & \text{kind definition}
      % auxilliary categories for definitions
      \\ 
      \\ checkType
      & ::= & \textbf{:}\ type
      & \textnormal{annotation for term definition}
      \\ param
      & ::= & \textbf{(}x\ \textbf{:}\ typeOrKind \textbf{)}
      \\ typeOrKind
      & ::= & type
      \\ & & kind
      \\ constr
      & ::= & \textbf{\textbar}\ id\ \textbf{:}\ type
    \end{array}
  \]
  \caption{Modules and definitions}
  \label{fig:mods-defs}
\end{figure}

\paragraph{Modules and Definitions}
All Cedilleum source files start with $mod$, which consists of a module
declaration, a sequence of import statements which bring into scope definitions
from other source files, and a sequence of \textit{commands} defining terms,
types, and kinds. As an illustration, consider the first few lines of a
hypothetical \texttt{list.ced}:

\begin{verbatim}
module list .

import nat .
\end{verbatim}

\noindent Imports are handled first by consulting a global options files
known to the Cedilleum compiler (on *nix systems \verb|~/.cedille/options|)
containing a search path of directories, and next (if that fails) by searching
the directory containing the file being checked.

Term and type definitions are given with an identifier, a classifer (type or
kind, resp.) to check the definition against, and the definition. For term
definitions, giving the type is optional. As an example, consider the
definitions for the type of Church-encoded lists and two variants of the nil
constructor, the first with a type annotation and the second without:

\begin{verbatim}
cList : ★ ➔ ★
      = λ A : ★ . ∀ X : ★ . (A ➔ X ➔ X) ➔ X ➔ X .

cNil  : ∀ A : ★ . cList · A
      = Λ A . Λ X . λ c . λ n . n .
cNil' = Λ A : ★ . Λ X : ★ . λ c : A ➔ X ➔ X . λ n : X . n .
\end{verbatim}


\begin{figure}
  \[
    \begin{array}{llll}
      \\ kind
      \\ & ::= & \textbf{Π}\ x\ \textbf{:}\ typeOrKind\ \textbf{.}\ kind
         & \textnormal{explicit product}
      \\ & & typeOrKind\ \textbf{➔}\ kind
         & \textnormal{kind arrow}
      \\ & & \textbf{★}
      \\ & & \textbf{(}kind\textbf{)}
      \\ type
      \\ & ::= & \textbf{Π}\ x\ \textbf{:}\ type\ \textbf{.}\ type
         & \textnormal{explicit product}
      \\ & &  \textbf{∀}\ x\ \textbf{:}\ typeOrKind\ \textbf{.}\ type
         & \textnormal{implicit product}
      \\ & &  \textbf{λ}\ x\ \textbf{:}\ typeOrKind\ \textbf{.}\ type
         & \textnormal{type-level function}
      \\ & & type\ \textbf{➾}\ type
         & \textnormal{arrow with erased domain}
      \\ & & type\ \textbf{➔}\ type
         & \textnormal{normal arrow type}
      \\ & & type\ \textbf{·}\ type
         & \text{application to another type}
      \\ & & type\ term
         & \text{application to a term}
      \\ & & \textbf{\{}\ uterm\ ≃\ uterm \textbf{\}}
         & \textnormal{untyped equality}
      \\ & & \textbf{(}type\textbf{)}
      \\ & & X
         & \text{type variable}
      \\ & & \bullet
         & \text{hole for incomplete types}
    \end{array}
  \]
  \caption{Kinds and types}
  \label{fig:kinds-types}
\end{figure}

\begin{figure}[h]
  \[
    \begin{array}{llll}
      \\ term
      & ::= & \textbf{λ}\ x\ class^?\ \textbf{.}\ term
      & \textnormal{normal abstraction}
      \\ & & \textbf{Λ}\ x\ class^?\ \textbf{.}\ term
      & \textnormal{erased abstraction}
      \\ & & \textbf{[}\ defTermOrType\ \textbf{]}\ \textbf{-}\ term
      & \textnormal{let}
      \\ & & \textbf{ρ}\ term\ \textbf{-}\ term
      & \text{equality elimination by rewriting}
      \\ & & \textbf{φ}\ term\ \textbf{-}\ term\ \textbf{\{} term \textbf{\}}
      & \text{type cast}
      \\ & & \textbf{χ}\ type^?\ \textbf{-}\ term
      & \text{check a term against a type}
      \\ & & \textbf{δ}\ \textbf{-}\ term
      & \text{ex falso quodlibet}
      \\ & & \textbf{θ}\ term\ term
      & \text{elimination with a motive}
      \\ & & term\ term
      & \text{applications}
      \\ & & term\ \textbf{-}\ term
      & \text{application to an erased term}
      \\ & & term\ \textbf{·}\ type
      & \text{application to a type}
      % \\ & & term\ arg^*
      % & \textnormal{applications}
      \\ & & \textbf{β}\ \textbf{\{} term \textbf{\}}
      & \textnormal{reflexivity of equality}
      \\ & & \textbf{ς}\ term
      & \textnormal{symmetry of equality}
      \\ & & \textbf{μ}\ term\ motive^?\ \textbf{\{}\ case^*\ \textbf{\}}
      & \textnormal{pattern match and fixpoint}
      \\ & & u
      & \text{term variable}
      \\ & & \textbf{(}term\textbf{)}
      \\ & & \bullet
      & \text{hole for incomplete term}
      \\
      \\ vararg
      & ::= & u
      & \text{normal constructor argument}
      \\ & & \textbf{-}\ u
      & \text{erased constructor argument}
      \\ & & \textbf{·}\ X
      & \text{type constructor argument}
      \\ class
      & ::= & \textbf{:}\ typeOrKind
      \\ motive
      & ::= & \textbf{@}\ type
      & \textnormal{motive for induction}
      \\ case
      & ::= & \textbf{\textbar}\ id\ arg^*\ \textbf{↦}\ term
      & \text{pattern-matching cases}
    \end{array}
  \]
  \caption{Annotated Terms}
  \label{fig:ann-terms}
\end{figure}

\end{document}