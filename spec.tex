\documentclass{article}

% \usepackage{todonotes}
\usepackage{amsmath,amssymb,amsthm}
%\usepackage{unicode-math}
\usepackage{url}
\usepackage{fullpage}

\usepackage{subcaption}
\usepackage{cedilleverbatim}
\usepackage{proof}

\DeclareUnicodeCharacter{03BC}{\ensuremath{\mu}}
\DeclareUnicodeCharacter{21A6}{\ensuremath{\mapsto}}
\DeclareUnicodeCharacter{25CF}{\ensuremath{\bullet}}
\DeclareUnicodeCharacter{1D48C}{\ensuremath{\kappa}}

% useful macros
\newcommand{\ann}[2]{#1\! : \! #2}
\newcommand{\abs}[4]{{#1}\, #2\! : \! #3.\, #4}
\newcommand{\absu}[3]{{#1}\, #2.\, #3}
\mathchardef\mhyph="2D % Define a "math hyphen"
\newcommand{\indast}[3]{\texttt{Ind } [#1]\ (#2 := #3)}
\newcommand{\lowerc}[1]{\lfloor {#1} \rfloor}
\newcommand{\lenc}[1]{\|#1\|}
\newcommand{\vars}[1]{{\overline{#1}}}

% - type inference
\newcommand{\decdir}{\vdash_{\delta}}
\newcommand{\decsyn}{\vdash_{\Uparrow}}
\newcommand{\decchk}{\vdash_{\Downarrow}}

\newcommand{\mufix}[3]{Œº\ #1\ .\ #2\ \{ #3 \}}
\newcommand{\mumat}[2]{Œº'\ #1\ \{#2\} }

\begin{document}

\title{The Cedilleum Language Specification \\ \large Syntax, Typing, Reduction,
  and Elaboration }

\author{Christopher Jenkins}

\maketitle

\section{Syntax}
\label{sec:syntax}

\paragraph{Identifiers}
\begin{figure}[h]
  \[
    \begin{array}{llll}
      id & &
      & \textnormal{identifiers for definitions}
      \\ u & &
      & \textnormal{term variables}
      \\ X & &
      & \textnormal{type variables}
      \\ ùíå & &
      & \textnormal{kind variables}
      \\ x & ::= & id\ |\ u\ |\ X\
      & \textnormal{non-kind variables}
      \\ y & ::= & x\ |\ ùíå & \text{all variables}
    \end{array}
  \]
  \caption{Identifiers}
  \label{fig:identifiers}
\end{figure}

Figure \ref{fig:identifiers} gives the metavariables used in our grammar for
identifiers. We consider all identifiers as coming from two distinct lexical
``pools'' -- regular identifiers (consisting of identifiers $id$ given for
modules and definitions, term variables $u$, and type variables $X$) and kind
identifiers $\kappa$. In Cedilleum source files (as in the parent language Cedille)
kind variables should be literally prefixed with $\kappa$ -- the suffix can be
any string that would by itself be a legal non-kind identifier. For example,
\texttt{myDef} is a legal term / type variable and a legal name for a
definition, whereas \texttt{ùíåmyDeff} is only legal as a kind definition.

\paragraph{Untyped Terms}
\begin{figure}[h]
  \[
    \begin{array}{llll}
      p
      & ::= & u
      & \text{variables}
      \\ & & \absu{\textbf{Œª}}{u}{p}
      & \text{functions}
      \\ & & p\ p'
      & \text{applications}
      \\ & & \mufix{u,u_I}{p_s}{pcase^*}
      & \text{fixed-point and pattern matching}
      \\ & & \textbf{Œº'}\ p_s\ \textbf{\{} pcase^* \textbf{\}}
      & \text{simple pattern matching}
      \\ \\ pcase
      & ::= & \textbf{\textbar}\ u\ u^* \mapsto p
    \end{array}
  \]
  \caption{Untyped terms}
  \label{fig:pure-terms}
\end{figure}

The grammar of pure (untyped) terms the untyped Œª-calculus augmented with a
primitives for combination fixed-point and pattern-matching definitions (and an
auxiliary pattern-matching construct).

\begin{figure}[h]
  \[
    \begin{array}{llll}
      % module stuff
      \\ mod
      & ::= & \textbf{module}\ id\ \textbf{.}\ imprt^*\ cmd^*\
      & \textnormal{module declarations}
      \\ imprt
      & ::= & \textbf{import}\ id\ \textbf{.}
      & \textnormal{module imports}
      \\ cmd
      & ::= & defTermOrType
      & \textnormal{definitions}
      \\ & & defDataType
      \\ & & defKind
      % definitions
      \\ 
      \\ defTermOrType
      & ::= & id\ checkType^?\ \textbf{=}\ t\ \textbf{.}
      & \textnormal{term definition}
      \\ & & id\ \textbf{:}\ K\ \textbf{=}\ T\ \textbf{.}
      & \textnormal{type definition}
      \\ defKind
      & ::= & ùíå\ \textbf{=}\ K
      & \text{kind definition}
      \\ defDataType
      & ::= & \textbf{data}\ id\ param^*\ \textbf{:}\ K\ \textbf{=}\
              constr^*\ \textbf{.}
      & \textnormal{datatype definitions}
     % auxilliary categories for definitions
      \\ 
      \\ checkType
      & ::= & \textbf{:}\ T
      & \textnormal{annotation for term definition}
      \\ param
      & ::= & \textbf{(}x\ \textbf{:}\ C \textbf{)}
      \\ constr
      & ::= & \textbf{\textbar}\ id\ \textbf{:}\ T
    \end{array}
  \]
  \caption{Modules and definitions}
  \label{fig:mods-defs}
\end{figure}

\paragraph{Modules and Definitions}
All Cedilleum source files start with production $mod$, which consists of a module
declaration, a sequence of import statements which bring into scope definitions
from other source files, and a sequence of \textit{commands} defining terms,
types, and kinds. As an illustration, consider the first few lines of a
hypothetical \texttt{list.ced}:

\begin{verbatim}
module list .

import nat .
\end{verbatim}

\noindent Imports are handled first by consulting a global options files
known to the Cedilleum compiler (on *nix systems \verb|~/.cedille/options|)
containing a search path of directories, and next (if that fails) by searching
the directory containing the file being checked.

Term and type definitions are given with an identifier, a classifier (type or
kind, resp.) to check the definition against, and the definition. For term
definitions, giving classifier (i.e. the type) is optional. As an example,
consider the definitions for the type of Church-encoded lists and two variants
of the nil constructor, the first with a top-level type annotation and the
second with annotations sprinkled on binders:

\begin{verbatim}
cList : ‚òÖ ‚ûî ‚òÖ
      = Œª A : ‚òÖ . ‚àÄ X : ‚òÖ . (A ‚ûî X ‚ûî X) ‚ûî X ‚ûî X .

cNil  : ‚àÄ A : ‚òÖ . cList ¬∑ A
      = Œõ A . Œõ X . Œª c . Œª n . n .
cNil' = Œõ A : ‚òÖ . Œõ X : ‚òÖ . Œª c : A ‚ûî X ‚ûî X . Œª n : X . n .
\end{verbatim}

Kind definitions are given without classifiers (all kinds have super-kind
$\Box$), e.g. \verb;ùíåfunc = ‚òÖ ‚ûî ‚òÖ;

Inductive datatype definitions take a set of \textit{parameters} (term and type
variables which remain constant throughout the definition) well as a set of
\textit{indices} (term and type variables which \textit{can} vary), followed by
zero or more constructors. Each constructor begins with ``\textbf{\textbar}''
(though the grammar can be relaxed so that the first of these is optional) and
then an identifier and type is given. As an example, consider the following two
definitions for lists and vectors (length-indexed lists).

\begin{verbatim}
data List (A : ‚òÖ) : ‚òÖ =
  | nil  : List
  | cons : A ‚ûî List ‚ûî List
  .
data Vec (A : ‚òÖ) : Nat ‚ûî ‚òÖ =
  | vnil  : Vec Z
  | vcons : ‚àÄ n : Nat . A ‚ûî Vec n ‚ûî Vec (S n)
  .
\end{verbatim}

\paragraph{Types and Kinds}
\begin{figure}[h]
  \[
    \begin{array}{rlll}
      \text{Sorts } S
      & ::= & \square & \text{sole super-kind}
      \\ & & K & \text{kinds}
      \\ \text{Classifiers } C
      & ::= & K & \text{types}
      \\ & & T & \text{types}
      \\ \text{Kinds } K
      & ::= & \textbf{Œ†}\ x\ \textbf{:}\ C\ \textbf{.}\ K
      & \textnormal{explicit product}
      \\ & & C\ \textbf{‚ûî}\ K
      & \textnormal{kind arrow}
      \\ & & \textbf{‚òÖ}
      & \text{the kind of types that classify terms}
      \\ & & \textbf{(}K\textbf{)}
      \\ 
      \\ \text{Types } T
      & ::= & \textbf{Œ†}\ x\ \textbf{:}\ T\ \textbf{.}\ T
         & \textnormal{explicit product}
      \\ & &  \textbf{‚àÄ}\ x\ \textbf{:}\ C\ \textbf{.}\ T
         & \textnormal{implicit product}
      \\ & &  \textbf{Œª}\ x\ \textbf{:}\ C\ \textbf{.}\ T
         & \textnormal{type-level function}
      \\ & & T\ \textbf{‚ûæ}\ T'
         & \textnormal{arrow with erased domain}
      \\ & & T\ \textbf{‚ûî}\ T'
         & \textnormal{normal arrow type}
      \\ & & T\ \textbf{¬∑}\ T'
         & \text{application to another type}
      \\ & & T\ t
         & \text{application to a term}
      \\ & & \textbf{\{}\ p\ ‚âÉ\ p' \textbf{\}}
         & \textnormal{untyped equality}
      \\ & & \textbf{(}T\textbf{)}
      \\ & & X
         & \text{type variable}
      \\ & & \bullet
         & \text{hole for incomplete types}
    \end{array}
  \]
  \caption{Kinds and types}
  \label{fig:kinds-types}
\end{figure}

In Cedilleum, the expression language is stratified into three main ``classes'':
kinds, types, and terms. Kinds and types are listed in Figure
\ref{fig:kinds-types} and terms are listed in Figure \ref{fig:ann-terms} along
with some auxiliary grammatical categories. In both of these figures, the
constructs forming expressions are listed from lowest to highest precedence --
``abstractors'' ($\lambda\ \Lambda\ \Pi\ \forall$) bind most loosely and
parentheses most tightly. Associativity is as-expected, with arrows (‚ûî ‚ûæ) and
applications being left-associative and abstractors being right-associative.

% TODO cite
The language of kinds and types is similar to that found in the Calculus of
Implicit Constructions\footnote{Cite}. Kinds are formed by dependent and
non-dependent products (Œ† and ‚ûî) and a base kind for types which can classify
terms (‚òÖ). Types are also formed by the usual (dependent and non-dependent)
products (Œ† and ‚ûî) and also \textit{implicit} products (‚àÄ and ‚ûæ) which quantify
over erased arguments (that is, arguments that disappear at run-time).
Œ†-products are only allowed to quantify over terms as all types occurring in
terms are erased at run-time, but ‚àÄ-products can quantify over types
\textit{and} terms because terms can be erased. Meanwhile, non-dependent
products (‚ûî and ‚ûæ) can only ``quantify'' over terms because non-dependent type
quantification does not seem particularly useful. Besides these, Cedilleum
features type-level functions and applications (with term and type arguments),
and a primitive equality type for untyped terms. Last of all is the ``hole''
type (‚óè) for writing partial type signatures or incomplete type applications.
There are term-level holes as well, and together the two are intended to help
facilitate ``hole-driven development'': any hole automatically generates a type
error and provides the user with useful contextual information.

We illustrate with another example: what follows is a module stub for
\textbf{DepCast} defining dependent casts -- intuitively, functions from $a : A$
to $B\ a$ that are also equal\footnote{Module erasure, discussed below} to
identity -- where the definitions \texttt{CastE} and \texttt{castE} are
incomplete.

\begin{verbatim}
module DepCast .

CastE ‚óÇ Œ† A : ‚òÖ . (A ‚ûî ‚òÖ) ‚ûî ‚òÖ = ‚óè .

castE ‚óÇ ‚àÄ A : ‚òÖ . ‚àÄ B : A ‚ûî ‚òÖ . CastE ¬∑ A ¬∑ B ‚ûæ Œ† a : A . B a = ‚óè .
\end{verbatim}

\paragraph{Annotated Terms}
\begin{figure}[h]
  \[
    \begin{array}{rlll}
      \text{Subjects } s
      & ::= & t & \text{term}
      \\ & & T & \text{type}
      \\ \text{Terms } t
      & ::= & \textbf{Œª}\, x\ class^?\! \textbf{.}\, t
      & \textnormal{normal abstraction}
      \\ & & \textbf{Œõ}\, x\ class^?\! \textbf{.}\, t
      & \textnormal{erased abstraction}
      \\ & & \textbf{[}\ defTermOrType\ \textbf{]}\ \textbf{-}\ t
      & \text{let definitions}
      \\ & & \textbf{œÅ}\ t\ \textbf{-}\ t'
      & \text{equality elimination by rewriting}
      \\ & & \textbf{œÜ}\ t\ \textbf{-}\ t'\ \textbf{\{} t'' \textbf{\}}
      & \text{type cast}
      \\ & & \textbf{œá}\ T\ \textbf{-}\ t
      & \text{check a term against a type}
      \\ & & \textbf{Œ¥}\ \textbf{-}\ t
      & \text{ex falso quodlibet}
      \\ & & \textbf{Œ∏}\ t\ t'^*
      & \text{elimination with a motive}
      \\ & & t\ t'
      & \text{applications}
      \\ & & t\ \textbf{-}t'
      & \text{application to an erased term}
      \\ & & t\ \textbf{¬∑}T
      & \text{application to a type}
      \\ & & \textbf{Œ≤}\ \textbf{\{} t \textbf{\}}
      & \textnormal{reflexivity of equality}
      \\ & & \textbf{œÇ}\ t
      & \textnormal{symmetry of equality}
      \\ & & \mufix{u,X,u_I}{t\ motive^?}{case^*}
      & \textnormal{type-guarded pattern match and fixpoint}
      \\ & & \mumat{t\ motive^?}{case^*}
      & \text{auxiliary pattern match}
      \\ & & u
      & \text{term variable}
      \\ & & \textbf{(}t\textbf{)}
      \\ & & \bullet
      & \text{hole for incomplete term}
      \\ \\ case
      & ::= & \textbf{\textbar}\ id\ vararg^*\ \textbf{‚Ü¶}\ t
      & \text{pattern-matching cases}
      \\ vararg
      & ::= & u
      & \text{normal constructor argument}
      \\ & & \textbf{-}u
      & \text{erased constructor argument}
      \\ & & \textbf{¬∑}X
      & \text{type constructor argument}
      \\ class
      & ::= & \textbf{:}\ C
      \\ motive
      & ::= & \textbf{@}\ T
      & \textnormal{motive for induction}
    \end{array}
  \]
  \caption{Annotated Terms}
  \label{fig:ann-terms}
\end{figure}

Terms can be explicit and implicit functions (resp. indicated by Œª and Œõ) with
optional classifiers for bound variables, let-bindings, applications $t\ t'$,
$t\ \mhyph t'$, and $t\ \cdot T$ (resp. to another term, an erased term, or a
type). In addition to this there are a number of useful operators that will be
discussed in more detail (and whose purpose will become more apparent) in Section
\ref{sec:type-system}.

\section{Erasure}

\begin{figure}[h]
  \[
  \begin{array}{lll}
       |x| & = & x 
    \\ |\star| & = & \star 
    \\ |\Box| & = & \Box 
    \\ |\beta\ \{t\}| & = & |t|
    \\ |\delta\ t| & = & |t|
    \\ |\chi\ T^? \textbf{-}\ t| & = & |t| 
    \\ |\theta\ t\ t'^*| & = & |t|\ |t'^*| 
    \\ |\varsigma\ t| & = & |t|
    \\ |t\ t'| & = & |t|\ |t'|
    \\ |t\ \mhyph t'| & = & |t| 
    \\ |t\ \cdot T| & = & |t| 
    \\ |\rho\ t\ \mhyph\ t'| & = & |t'| 
    \\ |\abs{\forall}{x}{C}{C'}| & = & \abs{\forall}{x}{|C|}{|C'|}
    \\ |\abs{\Pi}{x}{C}{C'}| & = & \abs{\Pi}{x}{|C|}{|C'|}
    \\ |\abs{\lambda}{u}{T}{t}| & = &  \absu{\lambda}{u}{|t|} 
    \\ |\absu{\lambda}{u}{t}| & = &  \absu{\lambda}{u}{|t|} 
    \\ |\abs{\lambda}{X}{K}{C}| & = &  \abs{\lambda}{X}{|K|}{|C|} 
    \\ |\abs{\Lambda}{x}{C}{t}| & = &  |t| 
    \\ |\phi\ t\ \mhyph\ t'\ \{t''\}| & = & |t''| 
    \\ |[ x = t : T]|\ \mhyph\ t' | & = & (\absu{\lambda}{x}{|t'|})\ |t|
    \\ |[X = T : K]\ \mhyph\ t | & = & |t| 
    \\ |\{ t \simeq t' \}|| & = & \{ |t| \simeq |t'| \}
    \\ |\mufix{u,X,u_I}{t\ motive^?}{case^*}|
           & = & \mufix{u,u_I}{t}{|case^*|}
    \\ |\mumat{t\ motive^?}{case^*}|
           & = & \mumat{t}{|case^*|}
    \\ \\ |id\ vararg^* \mapsto t| & = & id\ |vararg^*|\ \mapsto |t|
    \\ 
    \\ |\mhyph u| & = & 
    \\ |\cdot T|  & = &
  \end{array}
  \]
  \caption{Erasure for annotated terms}
  \label{fig:eraser}
\end{figure}

The definition of the erasure function given in Figure \ref{fig:eraser} takes
the annotated terms from Figures \ref{fig:kinds-types} and \ref{fig:ann-terms} to
the untyped terms of Figure \ref{fig:pure-terms}. The last two equations
indicate that any type or erased arguments in the the zero or more $vararg$'s of
pattern-match case are indeed erased. The additional constructs introduced in
the annotated term language such as Œ≤, œÜ, and œÅ, are all erased to the language
of pure terms.

\section{Type System (sans Inductive Datatypes)}
\label{sec:type-system}

\begin{figure}[h]
  \[ \small
    \begin{array}{lcr}
      \infer{\Gamma\vdash \star : \Box}{\ }
      & \infer
        { \Gamma\vdash\abs{\Pi}{y}{C}{C'} : S'}
        { \Gamma \vdash C : S
        \quad
        \Gamma,y:C\vdash C' : S'
%        \quad \textit{Var}(y,S)
        }
      & \infer
        {\Gamma\vdash\abs{\forall}{y}{C}{C'} : \star}
        {\Gamma \vdash C : S
        \quad \Gamma,y:C\vdash C' : \star
%        \quad \textit{Var}(y,S)
        }
      \\
      \\ \infer
      { \Gamma \vdash \{p \simeq p' \} : \star}
      { FV(p\ p') \subseteq dom(\Gamma) }
      & \infer
        { \Gamma \vdash \kappa : \Gamma(\kappa)}
        { }
      & \infer
        { \Gamma \vdash X : \Gamma(X)}
        { }
      \\
      \\ \infer
      { \Gamma \vdash \abs{\lambda}{x}{C}{T} : \abs{\Pi}{x}{C}{K}}
      { \Gamma \vdash \abs{\Pi}{x}{C}{K} : \square
      \quad \Gamma, \ann{x}{C} \vdash T : K
      }
      & \infer
        { \Gamma \vdash T\ \cdot T' : [T'/x] K'}
        { \Gamma \vdash T : \abs{\Pi}{x}{K}{K'}
        \quad \Gamma \vdash T' : K}
      & \infer
       { \Gamma \vdash T\ t : [t/x] K}
        { \Gamma \vdash T : \abs{\Pi}{x}{T'}{K}
        \quad \Gamma \decchk t : T' }
    \end{array}
  \]
  \caption{Sort checking \fbox{$\Gamma \vdash C : S$}}
  \label{fig:sort-checking}
\end{figure}

\begin{figure}[h]
  \[ \small
    \begin{array}{lcr}
      \infer
      { \Gamma \decdir u : \Gamma(u)}{}
      & \infer
        { \Gamma \decdir \abs{\lambda}{x}{T}{t} : \abs{\Pi}{x}{T}{T'}}
        { \Gamma \vdash T : K
        \quad \Gamma, \ann{x}{T} \decdir t : T'}
      & \infer
        { \Gamma \decchk \absu{\lambda}{x}{t} : \abs{\Pi}{x}{T}{T'}}
        { \Gamma, \ann{x}{T} \decchk t : T'}
      \\
      \\ \infer
      { \Gamma \decdir \abs{\Lambda}{x}{C}{t} : \abs{\forall}{x}{C}{T}}
      { \Gamma \vdash C : S
      \quad x \notin FV(|t|)
      \quad \Gamma, \ann{x}{C} \decdir t : T
      }
      & \infer
        { \Gamma \decchk \absu{\Lambda}{x}{t} : \abs{\forall}{x}{C}{T}}
        { x \notin FV(|t|)
        \quad \Gamma, \ann{x}{C} \decdir t : T
        }
      & \infer
        { \Gamma \decdir t\ t' : [t'/x]T}
        { \Gamma \decsyn t : \abs{\Pi}{x}{T'}{T}
        \quad \Gamma \decchk t' : T'}
      \\
      \\ \infer
      { \Gamma \decdir t\ \cdot T : [T/X]T'}
      { \Gamma \decsyn t : \abs{\forall}{X}{K}{T'}
      \quad \Gamma \vdash T : K}
      & \infer
        { \Gamma \decdir t\ \mhyph t' : [t'/x]T}
        { \Gamma \decsyn t : \abs{\forall}{x}{T'}{T}
        \quad \Gamma \decchk t' : T'}
      & \infer % conversion... maybe needs to include phi and rho now?
        { \Gamma \decchk t : T }
        { \Gamma \decsyn t : T'
          & |T'| =_{\beta} |T| }
      \\ \\ \infer
      { \Gamma \decdir [ id : T = t ]\ \mhyph\ t' : T'}
      { \Gamma \vdash T : K
        & \Gamma \decchk t : T
        & \Gamma, \ann{id = t}{T} \decdir t' : T'}
      & \infer
        { \Gamma \decdir [ id = t]\ \mhyph\ t' : T' }
        { \Gamma \decsyn t : T
          & \Gamma, \ann{id = t}{T} \decdir t' : T'
        }
      & \infer[\footnotemark] % TODO
        { \Gamma \decdir \rho\ t\ \mhyph\ t' : [t_2/x]\ T}
        { \Gamma \decsyn t : \{ t_1 \simeq t_2 \}
          & \Gamma \decsyn t' : [t_1/x]\ T
        }
      \\ \\ \infer
      { \Gamma \decdir [ id : K = T ]\ \mhyph\ t' : T'}
      { \Gamma \vdash K : \square
        & \Gamma \vdash T : K
        & \Gamma, \ann{id = T}{K} \decdir t' : T'}
      & \infer
        { \Gamma \decchk \beta \{t\} : \{ t' \simeq t' \}}
        { \Gamma \vdash \{ t' \simeq t' \} : \star }
      & \infer
        { \Gamma \decdir \varsigma\ t : \{ t_2 \simeq t_1 \} }
        { \Gamma \decdir t : \{ t_1 \simeq t_2 \}}
      \\ \\ \infer
      { \Gamma \decdir \phi\ t\ \mhyph\ t_1\ \{t_2\} : T}
      { \Gamma \decchk t : \{ |t_1| \simeq |t_2| \}
        & \Gamma \decdir t_1 : T}
      & \infer
        { \Gamma \decsyn \chi\ T\ \mhyph\ t : T }
        { \Gamma \decchk t : T }
      & \infer[\footnotemark]
        { \Gamma \decchk \delta\ \mhyph\ t : T }
        { \Gamma \decchk t : \{ \texttt{tt}\ \simeq\ \texttt{ff} \}}
      \\ \\ \infer
      { \Gamma \decchk \theta\ t\ t'^* : T }
      { \Gamma \decsyn t : \texttt{??}
        & \Gamma \vdash_? t'^* : \texttt{??} }
    \end{array}
  \]
  \caption{Type checking \fbox{$\Gamma \decdir s : C$} (sans inductive datatypes)}
  \label{fig:type-checking}
\end{figure}
\footnotetext{Where we assume $t$ does not occur anywhere in $T$}
\footnotetext{Where $\texttt{tt} = \absu{\lambda}{x}{\absu{\lambda}{y}{x}}$ and
  $\texttt{ff} = \absu{\lambda}{x}{\absu{\lambda}{y}{y}}$}
% TODO kind-variables... two different rules or Var check?
% TODO equality, now that it can have rho, phi

The inference rules for classifying expressions in Cedilleum are stratified into
two judgments. Figure \ref{fig:sort-checking} gives the uni-directional rules
for ensuring types are well-kinded and kinds are well-formed. Future versions of
Cedilleum will allow for bidirectional checking for both typing \textit{and}
sorting, allowing for a unification of these two figures. Most of these rules
are similar to what one would expect from the Calculus of Implicit
Constructions, so we focus on the typing rules unique to Cedilleum.

The typing rule for œÅ shows that œÅ is a primitive for rewriting by an (untyped)
equality. If $t$ is an expression that synthesizes a proof that two terms $t_1$
and $t_2$ are equal, and $t'$ is an expression synthesizing type $[t_1/x]\ T$
(where, as per the footnote, $t_1$ does not occur in $T$), then we may
essentially rewrite its type to $[t_2/x]\ T$. The rule for Œ≤ is reflexivity for
equality -- it witnesses that a term is equal to itself, provided that the type
of the equality is well-formed. The rule for œÇ is symmetry for equality.
Finally, œÜ acts as a ``casting'' primitive: the rule for its use says that if
some term $t$ witnesses that two terms $t_1$ and $t_2$ are equal, and $t_1$ has
been judged to have type $T$, then intuitively $t_2$ can also be judged to have
type $T$. (This intuition is justified by the erasure rule for œÜ -- the
expression erases to $|t_2|$). The last rule involving equality is for Œ¥, which
witnesses the logical principle \textit{ex falso quodlibet} -- if a certain
impossible equation is proved (namely that the two Church-encoded booleans
\texttt{tt} and \texttt{ff} are equal), then \textit{any} type desired is
inhabited.

The two remaining primitives are not essential to the theory but are useful
additions for programmers. The rule for œá allows the user to provide an
explicit top-level annotation for a term, and Œ∏ embodies ``elimination with a
motive'', using the expected type of an application to infer some type
arguments. (TODO)

\section{Inductive Datatypes}

Before we can provide the typing rules for introduction and usage of inductive
datatypes, some auxiliary definitions must be given. The syntax for these, and
the structure of this entire section, borrows heavily from the conventions of the Coq
documentation\footnote{https://coq.inria.fr/refman/language/cic.html\#inductive-definitions}.
The author believes it is worthwhile to restate this development in terms of the
Cedilleum type system, rather than merely pointing readers to the Coq
documentation and asking them to infer the differences between the two systems.

To begin with, the production $defDataType$ gives the concrete syntax for datatype definitions,
but it is not a very useful notation for representing one in the abstract syntax
tree. In our typing rules we will instead use the notation
$\indast{p}{\Gamma_I}{\Gamma_C}$ where $\Gamma_I$ is a context binding
\textit{one} type variable $I$ (representing the inductive datatype being defined),
$\Gamma_C$ represents the data constructors of type $I$, and $p$ is the number
of parameters to $I$. For example, consider the \texttt{List} and \texttt{Vec} definitions from
\ref{sec:syntax}. These will be represented in the AST as
\\ \\
\[\indast{1}{List : ‚òÖ ‚ûî ‚òÖ}
{\begin{array}{lcl}
   nil & : & ‚àÄ A : ‚òÖ . List \cdot A
   \\ cons & : & ‚àÄ A : ‚òÖ . A ‚ûî List \cdot A ‚ûî List \cdot A
 \end{array}
}\] and
\\
\[\indast{1}{Vec : ‚òÖ ‚ûî Nat ‚ûî ‚òÖ}
{\begin{array}{lcl}
   vnil & : & ‚àÄ A : ‚òÖ . Vec \cdot A\ Z
   \\ vcons & : & ‚àÄ A : ‚òÖ . ‚àÄ n : Nat . A ‚ûî Vec \cdot A\ n ‚ûî Vec \cdot A\ (S\ n)
 \end{array}
}\]

For an inductive datatype definition to be well-formed, it must satisfy the
following conditions (each of which is explained in more detail in the following
subsections):

\begin{itemize}
\item The kind of $I$ must be (at least) a \textit{p-arity of kind ‚òÖ}.
\item The types of each $id \in \Gamma_C$ must be \textit{types of constructors
    of $I$}
\item The definition must satisfy the \textit{non-strict} positivity condition.
\end{itemize}

\subsection{Auxiliary Definitions}

\paragraph{$p$-arity}

A kind $K$ is a $p$-arity if it can be written as $\absu{\Pi}{\Gamma_P}{K'}$ for
some $\Gamma_P$ and $K'$, where $\lenc{\Gamma_p} = p$ and $\Pi\,\Gamma_P$ represents
the explicit quantification of all term and type variables in $\Gamma_P$
(similarly, $\forall\, \Gamma_P$ represents the \textit{implicit} quantification
of these variables). For an inductive definition
$\indast{p}{\Gamma_I}{\Gamma_C}$, requiring that the kind of $I$ is a $p$-arity
of ‚òÖ ensures that $I$ \textit{really does have} $p$ parameters.

\paragraph{Types of Constructors}

$T$ is a \textit{type of a constructor of $I$} if
\begin{itemize}
\item it is $I\ s_1 ... s_n$
\item it can be written as $\abs{\forall}{s}{C}{T}$ or $\abs{\Pi}{s}{C}{T}$,
  where (in either case) $T$ is a type of a constructor of $I$
\end{itemize}

\paragraph{Positivity condition}
The positivity condition is defined in two parts: the positivity condition of
a type $T$ of a constructor of $I$, and the positive occurence of $I$ in $T$.
We say that a type $T$ of a constructor of $I$ satisfies the positivity condition
when

\begin{itemize}
\item $T$ is $I\ s_1... s_n$ and $I$ does not occur anywhere in $s_1...s_n$
\item $T$ is $\abs{\forall}{s}{C}{T'}$ or $\abs{\Pi}{s}{C}{T'}$, $T'$ satisfies
  the positivity condition for $I$, and $I$ occurs \textit{only} positively in $C$ 
\end{itemize}

\noindent We say that $I$ occurs only positively in $T$ when
\begin{itemize}
\item $I$ does not occur in $T$
\item $T$ is of the form $I\ s_1 ... s_n$ and $I$ does not occur in $s_1 ...
  s_n$
\item $T$ is of the form $\abs{\forall}{s}{C}{T'}$ or $\abs{\Pi}{s}{C}{T'}$, $I$
  occurs only positively in $T'$, and $I$ \textit{does not} occur positively in $C$
\end{itemize}

\paragraph{Well-formed patterns}
TODO: erasure, exhaustiveness, non-overlapping

\subsection{Well-formed inductive definitions}

Let $\Gamma_P,\Gamma_I,$ and $\Gamma_C$ be contexts such that $\Gamma_I$
associates a single type-variable $I$ to kind $\absu{\Pi}{\Gamma_P}{K_I}$ and
$\Gamma_c$ associates term variables $c_1 ... c_n$ with corresponding types
$\absu{\forall}{\Gamma_P}{T_{1}},...\absu{\forall}{\Gamma_P}{T_{n}}$. Then the
rule given in Figure \ref{fig:inductive-intro} states when an inductive datatype
definition may be introduced, provided that the following side conditions hold:

\begin{figure}[h]
  \caption{Introduction of inductive datatype}
  \label{fig:inductive-intro}
  \[
    \infer
    { \Gamma \vdash \indast{p}{\Gamma_I}{\Gamma_C}\ wf}
    { \Gamma_P \vdash K_I : \square
      \quad (\Gamma_I,\Gamma_P \vdash T_{c_i} : ‚òÖ)_{i=1..n}
    }
  \]
\end{figure}

\begin{itemize}
  \item Names $I$ and $c_1..c_n$ are distinct from any other inductive datatype
    type or constructor names, and distinct amongst themselves
  \item $\lenc{\Gamma_P} = p$
  \item Each of $T_1..T_n$ is a type of constructor of $I$ which satisfies the
    positivity condition for $I$
  \item No other previously defined inductive datatypes $I'$ nor constructors
    $c'_1..c'_{n'}$ occur anywhere in $\Gamma_P$,$\Gamma_I$, or $\Gamma_C$
\end{itemize}

\subsection{Typing Rules}

\begin{figure}[h]
  \caption{Use of an inductive datatype $\indast{p}{\Gamma_I}{\Gamma_C}$}
  \label{fig:inductive-use}
  \[
    \begin{array}{lr}
      \infer
      { \Gamma \vdash I : \Gamma_I(I) }
      { }
      &  \infer
        { \Gamma \decdir c : \Gamma_C(c) }
        { }
    \end{array}
    \] \par\medskip \[
    \begin{array}{c}
      \infer
      { \Gamma,\Gamma_{\mu} \decdir
        \mumat
        {t\ @\absu{\lambda}{\Gamma_D}{\abs{\lambda}{x}{I\ \lowerc{\Gamma_P}\
         \lowerc{\Gamma_D}}{T}}}
        {(|\ c_i\ \lowerc{\Gamma_{A_i}} \mapsto t_i)}
        : [\vars{s}/\lowerc{\Gamma_D},t/x]\ T
        % \mu'\ t\ @
      % \absu{\lambda}{\Gamma_D}{\abs{\lambda}{x}{I\ \lowerc{\Gamma_P}\
      % \lowerc{\Gamma_D}}{T}} : [\vars{s}/\lowerc{\Gamma_D},t/x]\ T
      }
      {
      \begin{array}{c}
      \begin{array}{lr}
        \Gamma \decsyn t : I\ \lowerc{\Gamma_P}\ \vars{s}
        & \Gamma_{\mu}(I)\!=\!\indast{\Gamma_P}{\Gamma_I}{\Gamma_C},\lenc{\Gamma_C}=n
        \\ \\ \Gamma,\Gamma_D,\ann{x}{I\ \lowerc{\Gamma_P}\ \lowerc{\Gamma_D}}
          \vdash T : ‚òÖ
        & (c_i \in \Gamma_C \text{ and } \Gamma \decsyn c_i\ \lowerc{\Gamma_P}
          \lowerc{\Gamma_{A_i}} : I\ \lowerc{\Gamma_P}\ \vars{s_i})_{i=1..n}
      \end{array}
        \\ \\ (\Gamma,\Gamma_{A_i} \vdash t_i :
        [\vars{s_i}/\lowerc{\Gamma_D},(c_i\ \lowerc{\Gamma_P}\
        \lowerc{\Gamma_{A_i}})/x]\ T
        \quad erased(\Gamma_{A_i}) \cap FV(|t_i|) = \varnothing
        )_{i=1..n}
      \end{array}
      }
    \end{array}
  \]
\end{figure}

Assuming that an inductive definition $\indast{p}{\Gamma_I}{\Gamma_C}$ is
well-formed and has been defined, the typing rules of Figure
\ref{fig:inductive-use} govern its usage.

The rules for typing uses of $\mu$ and $\mu'$ are fairly involved. We will start
with the latter, since its the simpler of the two and overlaps a good deal with
the former. Before diving into the details of these rules, we need to understand
a few notational conventions. First, $\Gamma_{mu}$ is a special context of type
variables tracking which ones are inductive by associating them with their
inductive declaration. Second, the notation $\lowerc{\Gamma}$ indicates a
sequence of variable arguments given by context $\Gamma$. For example, if
$\Gamma_P = A : ‚òÖ$ and $\Gamma_D = n : Nat$, then the type written $Vec\ 
\lowerc{\Gamma_P}\ \lowerc{\Gamma_D}$ is equivalent to $Vec \cdot A\ n$
\footnote{With the kind of $Vec$ guiding which flavor of application is
  appropriate.} By convention, $\Gamma_D$ is meant to be read as the ``context
of type in\textbf{d}ices''. Finally, $\lenc{\Gamma}$ represents the number of
associated variables in $\Gamma$.

The $\mu'$ operator performs simple pattern-matching and has three components.
The first component is the scrutinee $t$, and the first and second premises of
this typing rule ensure that $t$ really is an inductive data type by checking
that it is indeed well-typed, that its type is some variable-headed application,
and that this variable head has a corresponding inductive definition. The next
component is the \textit{motive}, which is preceded by the $@$ symbol.
Essentially, type $T$ is the property the programmer wishes to prove, and $\mu'$
allows them to do so by \textit{case analysis}. We check that the motive is
well-kinded in the third premise. The last component of $\mu'$ is the cases
covering the constructors of $I$. Each constructor case $c_i$ comes with its own
sub-data held in $\Gamma_{A_i}$; the fourth premise checks that each $c_i$
really is a constructor and the left-hand side patterns are type-correct
(applied to the right number of arguments and of the right flavor of
application.) Left implicit in these premises is the condition that each $c_i$
be mutually distinct. The fifth premise checks that each right-hand side of the
case is well-typed, given the new arguments introduced by $\Gamma_A$, and that
arguments of a case analysis introduced in an erased position are used
correctly. Each $t_i$ is expected to have a type derived from $T$, where the
indices $\Gamma_D$ have been replaced by the particular constructor's
$\vars{s_i}$ and the abstracted subject of case analysis $x$ by $c_i$ applied to
its arguments.


\end{document}